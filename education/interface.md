Интерфейсы

В Java: Интерфейс — это формальный контракт. Это прежде всего обязательство класса реализовать определенное поведение т.е. набор методов.

В Go: Интерфейс — это набор поведения. Это не контракт, который нужно подписать, а абстракция, которая просто существует. Если мой тип ведёт себя определённым образом (имеет методы с нужными сигнатурами), он автоматически и неявно удовлетворяет интерфейсу. Эта концепция называется Duck Typing: "Если что-то ходит как утка и крякает как утка, то это утка".

1. Чтобы объявить интерфейс, используется ключевое слово type, затем указывается имя интерфейса и ключевое слово interface

type MyInterface interface {
	MyMethod()
}

2. В Go интерфейсы поддерживает встраивание. Для этого нужно в объявлении нового интерфейса указать название какого-то другого интерфейса

type I interface {
	MyInterface
}

3. Для того, чтобы удовлетворять интерфейсу, достаточно просто реализовать его методы. В Go интерфейсы определяются со стороны потребителя, а не со стороны реализатора. Я могу взять любой тип из любой чужой библиотеки и сделать его удовлетворяющим моему интерфейсу, просто потому что у него уже есть нужные методы

// Animal - это интерфейс. Он определяет поведение.
type Animal interface {
    MakeSound()
}

// Go: НЕЯВНАЯ реализация интерфейса
type Dog struct{}

// У типа Dog есть метод MakeSound с нужной сигнатурой.
// Этого достаточно. Нигде не нужно писать "implements".
func (d Dog) MakeSound() {
    fmt.Println("Woof!")
}

// Функция принимает интерфейс Animal.
// Мы можем передать в неё ЛЮБОЙ тип, у которого есть метод MakeSound().
func Pet(a Animal) {
    a.MakeSound()
}

func main() {
    dog := Dog{}
    Pet(dog) // Dog неявно реализует Animal. Это работает.
}

4. У интерфейсов (как и у любых других идентификаторов в Go) есть область видимости. Она определяется правилами Go: имя с большой буквы — экспортируемое (публичное), с маленькой буквы — неэкспортируемое (приватное, в пределах пакета)

package mypackage

// PublicInterface - экспортируется (виден из других пакетов)
// Его можно использовать при импорте "mypackage"
type PublicInterface interface {
    Save() error
}

// privateInterface - НЕ экспортируется (виден только внутри mypackage)
type privateInterface interface {
    internalHelper()
}

5. Правила работы с интерфейсами:
    * интерфейсы должны быть маленькими. Принцип Interface Segregation Principle (ISP) доведен до абсолюта. Лучший интерфейс — это интерфейс с одним методом (io.Reader, io.Writer)
    * функциям стоит принимать интерфейсы — это делает их гибкими и тестируемыми
    * функциям стоит возвращать конкретные структуры — иначе вы навязываете клиенту зависимость от вашей абстракции
    * определять интерфейс в пакете, где он используется (часто это лучшая практика), и тогда мне даже не нужно его импортировать
    * использовать встраивание интерфейсов (Composition):
type ReadWriter interface {
    Reader  // Встраивает все методы из интерфейса Reader
    Writer  // Встраивает все методы из интерфейса Writer
}

5. Пустой интерфейс (interface{}) и Type Assertions (уже вроде не юзают, вместо этого дженерики, поэтому позже)
