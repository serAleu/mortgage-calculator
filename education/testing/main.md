Тестирование в Go

Философия:
1. Тесты — это код. Тест — это обычная Go-функция, которую я пишу сам
2. Максимальная простота. Нет встроенных моков, assertion-библиотек и DSL. Всё делается стандартными средствами языка (if, t.Error)
3. Интеграция в инструментарий. Тестирование — это команда go test, а не отдельный фреймворк
4. Приоритет юнит-тестов. Акцент на изолированное тестирование небольших модулей

Анатомия тестового файла:
1. Имя файла: Тестовый файл всегда должен заканчиваться на _test.go.
    * calculator.go — production-код.
    * calculator_test.go — тесты для кода из calculator.go.
2. Имя функции: Тестовая функция должна начинаться с Test (с большой буквы) и принимать один аргумент: t *testing.T.
    * func TestCalculate(t *testing.T) { ... } — правильно.
    * func test_calculate(t *testing.T) { ... } — НЕправильно (не экспортируется тк приватная область видимости).
3. Пакет: Тесты обычно находятся в том же пакете, что и тестируемый код. Это даёт доступ к неэкспортируемым (unexported) функциям и переменным для полноценного white-box тестирования.

testing.T:
1. testing.T - главный инструмент тестирования, это handle для управления состоянием теста. Его ключевые методы:
    * t.Error(args...) / t.Errorf(format, args...)   - Завершить тест с ошибкой, но продолжить выполнение остальных тестов в этом файле.
    * t.Fatal(args...) / t.Fatalf(format, args...)   - Немедленно завершить тест (и все последующие в этой функции). Используется, если дальнейшее выполнение бессмысленно (например, не удалось подключиться к БД).
    * t.Log(args...) / t.Logf(format, args...)	     - Вывести лог. Виден только при детализированном выводе (-v флаг) или при падении теста.
    * t.Run(name string, subtest func(t *testing.T)) - Запустить подтест (subtest). Позволяет группировать логику.
    * t.Helper()	                                 - Пометить функцию как test helper. Её имя тогда не будет показываться в стектрейсе ошибки, что упрощает дебаг.
    * t.Skip(args...)                                - Пропустить этот тест. Например, если нет нужной переменной окружения.
    * t.Parallel()                                   - Пометить тест как параллельный. Такие тесты могут запускаться concurrently с другими Parallel() тестами.
 
